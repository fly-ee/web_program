<!DOCTYPE html>
<html>
<head>
	<title>e</title>
	<h3>some visualizer thing</h3>
	<meta charset="UTF-8">
  <meta name="viewport" content="width=device-width,initial-scale=0.5">
</head>

<body style="background-color:#a0a0a0;">
	<div id="programs">
		<span style="margin-left:3px;font-size:20px;">programs</span>
		<style>
			#programs {
				width: 350px;
				height: 30px;
				transition: width 0.5s ease, height 0.5s ease;
				overflow: hidden;
				background-color: #acac95;
				border-top-color: #bbbba4;
				border-right-color: #bbbba4;
				border-bottom-color: #9d9d86;
				border-left-color: #9d9d86;
				border-width: 2px;
				border-style: solid;
			}
		</style>
		<script>
			const div = document.getElementById('programs');
			let locked = false; // prevent the programs tab from collapsing when a program is running
			function fold() {
				let style = getComputedStyle(div);
				if (style.height == '30px' && !locked) {
					div.style.height = '550px';
				} else if (style.height == '550px' && !locked) {
					div.style.height = '30px';
				};
				if (locked) {
					alert("cannot run other programs while another program is running.")
				};
			};

			function forceClose() {
				div.style.height = '30px';
			}
		</script>
		<button style="width:170px;height:30px;margin-left:85px;" onClick="fold()">expand/collapse</button>
		<hr id="seperator" style="background-color:#9d9d86;border-top-color:#bbbba4;border-right-color:#bbbba4;border-bottom-color:#9d9d86;border-left-color:#9d9d86;border-width:2px;border-style:solid;">
		<div style="width:260px;height:305px;">
			<progress id="prog" min="0" max="0" value="0" style="width:340px;margin-left:5px;"></progress>
			<span id="bytes" style="font-size:17px;margin-left:5px;">0B / 0B</span>
			<input type="file" style="width:220px;margin:5px;" id="input">
			<button id="stop" style="margin-left:5px;">stop</button>
			<input type="checkbox" id="compile"><span>Compile output</span></input>
			<button id="retry" style="margin-left:5px;margin-top:2px;">retry</button>
			<canvas width="256" height="256" id="output" style="background-color:black;border-top-color:#bbbba4;border-right-color:#bbbba4;border-bottom-color:#9d9d86;border-left-color:#9d9d86;border-width:2px;border-style:solid;margin:5px;"></canvas>
			<script>
				const output = document.getElementById('output');
				const oCtx = output.getContext('2d');
				oCtx.save();
				const input = document.getElementById('input');
				const stop = document.getElementById('stop');
				stop.disabled = true;
				const retry = document.getElementById('retry');
				retry.disabled = true;
				const progbar = document.getElementById("prog");
				const byteDisplay = document.getElementById("bytes");

				function format(bytes) {
					const units = ["B", "KB", "MB", "GB", "TB", "PB"];
					let i = 0;
					while (bytes >= 1024 && i < units.length - 1) {
						bytes /= 1024;
						i++;
					};
					return bytes.toFixed(2) + units[i];
				};

				function strToBytes(str) {
					return [...str].map(c => c.charCodeAt(0));
				};

				function compileATVA(frames, audioBytes = []) {
					const frameStart = [0xFF, 0x00];
					const lineEnd = [0xE7, 0xEF, 0xF2, 0x00];
					const frameEnd = [0x00, 0xEF, 0xEF, 0xF7, 0x00];
					const audioStart = [0xEB, 0xEB, 0xEB, 0xEB, 0xA4, 0x00];
					const audioEnd = [0xEB, 0xEB, 0xEB, 0xEB, 0xA5];
					const fileEnd = [0xE9, 0xE9, 0xE9, 0xE9, 0x00, 0xFF, 0x00];
					let bytes = [
						...strToBytes("flt: atva"), 0x00,
						...strToBytes("fr: 1"), 0x00
					];
					for (const frame of frames) {
						bytes.push(...frameStart);
						for (let i = 0; i < frame.length; i += 256 * 3) {
							bytes.push(...frame.slice(i, i + 256 * 3)); // One line of RGB
							bytes.push(...lineEnd);
						}
						bytes.push(...frameEnd);
					};
					if (audioBytes.length > 0) {
						bytes.push(...audioStart, ...audioBytes, ...audioEnd);
					};
					bytes.push(...fileEnd);
					return new Uint8Array(bytes);
				};

				function visualize() {
					const file = input.files[0];
					if (file) {
						const reader = new FileReader();
						reader.onload = function(e) {
							retry.disabled = true;
							const arrayBuffer = e.target.result;
							const arr = new Uint8Array(arrayBuffer);
							progbar.max = arr.length;
							const aCtx = new(AudioContext || webkitAudioContext)();
							const samples = new Float32Array(arr.length);
							for (let i = 0; i < arr.length; i++) {
								samples[i] = (arr[i] - 128) / 128;
							};
							const buf = aCtx.createBuffer(1, samples.length, 8000);
							buf.getChannelData(0).set(samples);
							const src = aCtx.createBufferSource();
							src.buffer = buf;
							src.connect(aCtx.destination);
							src.start();
							input.disabled = true;
							let i = 0;
							let y = 0;
							let o = 0;
							let r = 0;
							let frames = [];
							stop.disabled = false;
							let timeout = 32;
							if (arr.lenght > 100000) {
								timeout = 1;
							} else if (arr.length > 50000) {
								timeout = 10;
							} else if (arr.length < 5000) {
								timeout = 50;
							};
							let size = format(arr.length);
							const iInt = setInterval(() => {
								for (let j = 0; j < 256; j += 2) {
									if (arr[j + o + i + 1] || arr[j + o + i + 2]) {
										oCtx.fillStyle = `rgb(${arr[j + o + i]},${arr[j + o + i + 1]},${arr[j + o + i + 2]})`;
										oCtx.fillRect(j, 254, 2, 2);
									} else {
										arr[j + o + i + 1] = 0;
										arr[j + o + i + 2] = 0;
									};
								};
								o += 255;
								i += 2;
								progbar.value = i + o;
								byteDisplay.textContent = `${format(i + o)} / ${size}`;
								/*if (y == output.height) {
								let raw = oCtx.getImageData(0, 0, 256, 256).data;
								let rgbFrame = [];
								for (let y = 0; y < 256; y += 4) {
								for (let x = 0; x < 256; x += 4) {
								let i = (y * 256 + x) * 4;
								rgbFrame.push(raw[i], raw[i + 1], raw[i + 2]); // skip alpha
								};
								};
								frames.push(rgbFrame);
								y = 0;
								};*/
								if (i >= (arr.length - o)) {
									i = 0;
									o = 0;
									src.stop();
									input.disabled = false;
									stop.disabled = true
									if (document.getElementById('compile').value == true) {
										let blob = new Blob([compileATVA(frames)], { type: 'application/octet-stream' });
										let link = document.createElement("a");
										link.href = URL.createObjectURL(blob);
										link.download = "output.atva";
										link.click();
									};
									retry.disabled = false;
									clearInterval(iInt);
								};
								oCtx.drawImage(output, 0, -2);
							}, 1);
							stop.addEventListener('click', (e) => {
								i = 0;
								o = 0;
								src.stop();
								input.disabled = false;
								stop.disabled = true;
								retry.disabled = false;
								clearInterval(iInt);
							});
						};
						reader.readAsArrayBuffer(file);
						retry.disabled = true;
					};
				};
				input.addEventListener('change', function() { visualize() });
				retry.addEventListener('click', function() { visualize() });
			</script>
		</div>
	</div>
</body>
</html>
